defpackage chipper.passes:
  import core
  import verse
  import chipper.ir
  import widthsolver

;============== EXCEPTIONS =================================
defclass PassException <: Exception
defn PassException (msg:String) :
  new PassException :
    defmethod print (o:OutputStream, this) :
      print(o, msg)

;================ UTILITIES ================================
defn* root-ref (i:Immediate) :
   match(i) :
      (f:Field) : root-ref(imm(f))
      (r) : r
      
defn lookup<?T> (e: Streamable<KeyValue<Immediate,?T>>, i:Immediate) :
   for entry in e search :
      if eqv?(key(entry), i) :
         value(entry)

defn lookup!<?T> (e: Streamable<KeyValue<Immediate,?T>>, i:Immediate) :
   lookup(e, i) as T

;============ CHECK IF NAMES ARE UNIQUE ====================
defn check-duplicate-symbols (names: Streamable<Symbol>, msg: String) :
  val dict = HashTable<Symbol, True>(symbol-hash)
  for name in names do:
    if key?(dict, name):
      throw $ PassException $ string-join $
      [msg ": " name]
    else:
      dict[name] = true

defn check-duplicates (t: Type) :
  match(t) :
    (t:BundleType) :
      val names = map(name, ports(t))
      check-duplicate-symbols{names, string-join(_)} $
        ["Duplicate port name in bundle "]
      do(check-duplicates{type(_)}, ports(t))
    (t) : false

defn check-duplicates (c: Command) :
  match(c) :
    (c:DefWire) : check-duplicates(type(c))
    (c:DefRegister) : check-duplicates(type(c))
    (c:DefMemory) : check-duplicates(type(c))
    (c:DefVector) : check-duplicates(type(c))
    (c) : do(check-duplicates, children(c))

defn defined-names (c: Command) :
  generate<Symbol> :
    loop(c) where :
      defn loop (c:Command) :
        match(c) :
          (c:Command&HasName) : yield(name(c))
          (c) : do(loop, children(c))

defn check-duplicates (m: Module):
  ;Check all duplicate names in all types in all ports and body
  do(check-duplicates{type(_)}, ports(m))
  check-duplicates(body(m))

  ;Check all names defined in module
  val names = concat(stream(name, ports(m)),
                     defined-names(body(m)))
  check-duplicate-symbols{names, string-join(_)} $
    ["Duplicate definition name in module " name(m)]

defn check-duplicates (c: Circuit) :
  ;Check all duplicate names in all modules
  do(check-duplicates, modules(c))

  ;Check all defined modules
  val names = stream(name, modules(c))
  check-duplicate-symbols(names, "Duplicate module name")


;=============== RESOLVE KINDS =============================
defn resolve-kinds (m:Module) -> Module :
   val kind = HashTable<Symbol,Symbol>(symbol-hash)
   defn find-kinds (c:Command) -> False :
      match(c) :
         (c:DefUInt|DefSInt|DoPrim) :
            kind[name(c)] = `node
         (c:DefWire) :
            kind[name(c)] = `wire
         (c:DefRegister) :
            kind[name(c)] = `reg
         (c:DefInstance) :
            kind[name(c)] = `inst
         (c:DefMemory|DefVector) :
            kind[name(c)] = `source
         (c:DefAccessor) :
            kind[name(c)] = `accessor
         (c) :
            do(find-kinds, children(c))         

   defn resolve-kinds (i:Immediate) -> Immediate :
      defn ref-name (r:Immediate) :
         name(r as Ref)
      defn reg? (i:Immediate) :
         match(i) :
            (i:Ref) : kind[name(i)] == `reg
            (i) : false
      defn inst? (i:Immediate) :
         match(i) :
            (i:Ref) : kind[name(i)] == `inst
            (i) : false               
      match(i) :
         (i:Field) :
            switch _{imm(i)} :
               reg? :
                  switch {name(i) == _} :
                     `data : RegData(ref-name(imm(i)))
                     `init : RegInit(ref-name(imm(i)))
                     else : error("Invalid register field")
               inst? :
                  InstPort(ref-name(imm(i)), name(i))
               else :
                  put-imm(i, resolve-kinds(imm(i)))
         (i) : i
         
   defn resolve-kinds (c:Command) -> Command :
      var c*:Command = c
      c* = map(resolve-kinds{_ as Immediate}, c*)
      c* = map(resolve-kinds{_ as Command}, c*)
      c*

   ;Find all kinds
   for p in ports(m) do :
      kind[name(p)] = `wire
   find-kinds(body(m))
   Module(name(m),
          ports(m),
          resolve-kinds(body(m)))

defn resolve-kinds (c:Circuit) -> Circuit :
   Circuit(
      map(resolve-kinds, modules(c))
      main(c))

;=============== MAKE RESET EXPLICIT =======================
defn make-explicit-reset (c: Command) -> Command :
   match(c) :
      (c:DefInstance) :
         val c2 = Connect(InstPort(name(c), `reset), Ref(`reset))
         Begin(list(c, c2))
      (c) :
         map(make-explicit-reset{_ as Command}, c)

defn make-explicit-reset (m: Module) :
   val reset = Port(`reset, INPUT, UIntType(IntWidth(1)))
   Module(name(m),
          List(reset, ports(m)),
          make-explicit-reset(body(m)))

defn make-explicit-reset (c: Circuit) :
   val modules* = map(make-explicit-reset, modules(c))
   Circuit(modules*, main(c))
   

;======= MAKE EXPLICIT REGISTER INITIALIZATION =============
defn reg-inits (e: List<KeyValue<Symbol,Immediate>>) :
   if empty?(e) :
      EmptyCommand()
   else :
      val connections = Begin $ to-list $
         for entry in e map :
            Connect(RegData(key(entry)), value(entry))
      Conditionally(
         Ref(`reset),
         connections,
         EmptyCommand())

;e is a mapping of (register => init wire)
defn initialize-registers (c: Command
                           e: List<KeyValue<Symbol,Immediate>>) ->
                           [Command, List<KeyValue<Symbol,Immediate>>] :

   defn replace-init (i:Immediate) :
      match(i) :
         (i:RegInit) : lookup!(e, name(i))
         (i:Field) : put-imm(i, replace-init(imm(i)))
         (i) : i

   match(c) :
      (c:DefRegister) :
         val w = Ref(gensym())
         val c* = Begin $ to-list $ [
            c
            DefWire(name(w), type(c))
            Connect(w, RegData(name(c)))]
         [c*, list(name(c) => w)]   
      (c:Conditionally) :
         val pred* = replace-init(pred(c))
         val [conseq* con-e] = initialize-registers(conseq(c), e)
         val [alt* alt-e] = initialize-registers(alt(c), e)
         val c* =
            Conditionally(
               pred*
               Begin(list(conseq*, reg-inits(con-e)))
               Begin(list(alt*, reg-inits(alt-e))))
         [c*, List()]
      (c:Begin) :
         var current-e:List<KeyValue<Symbol,Immediate>> = e
         val defined = Vector<KeyValue<Symbol,Immediate>>()
         val body* =
            for c in body(c) map :
               val [c* e*] = initialize-registers(c, current-e)
               current-e = append(e*, current-e)
               do(add{defined, _}, e*)
               c*
         [Begin(body*), to-list(defined)]
      (c) :
         [map(replace-init, c), List()]

defn initialize-registers (m:Module) :
   val body* = let :
      val [body* regs] = initialize-registers(body(m), List())
      Begin(list(body*, reg-inits(regs)))
   Module(name(m), ports(m), body*)

defn initialize-registers (c:Circuit) :
   val modules* = map(initialize-registers, modules(c))
   Circuit(modules*, main(c))


;============== INFER TYPES ================================
defn lookup-port (ports: Streamable<Port>, port-name: Symbol) :
   for port in ports find :
      name(port) == port-name

defn infer (op:PrimOp, arg-types: List<Type>) -> Type :
   defn wipe-width (t:Type) :
      match(t) :
         (t:UIntType) : UIntType()
         (t:SIntType) : SIntType()
         
   switch {op == _} :
      ADD-OP : wipe-width(arg-types[0])
      ADD-MOD-OP : wipe-width(arg-types[0])
      SUB-MOD-OP : wipe-width(arg-types[0])
      MINUS-OP : wipe-width(arg-types[0])
      TIMES-OP : wipe-width(arg-types[0])
      DIVIDE-OP : wipe-width(arg-types[0])
      MOD-OP : wipe-width(arg-types[0])
      SHIFT-LEFT-OP : wipe-width(arg-types[0])
      SHIFT-RIGHT-OP : wipe-width(arg-types[0])
      PAD-OP : wipe-width(arg-types[0])
      BITS-SELECT-OP : wipe-width(arg-types[0])
      MULTIPLEX-OP : wipe-width(arg-types[1])
      else : UIntType()

defn bundle-field (t:Type, n:Symbol) :
   match(t) :
      (t:BundleType) :
         match(lookup-port(ports(t), n)) :
            (p:Port) : type(p)
            (p) : UnknownType()
      (t) : UnknownType()

defn infer (c:Command, e:List<KeyValue<Symbol, Type>>) -> [Command, List<KeyValue<Symbol,Type>>] :
   defn put-types (i:Immediate) :
      match(i) :
         (i:Ref) :
            put-type(i, lookup!(e, name(i)))
         (i:RegData) :
            put-type(i, lookup!(e, name(i)))
         (i:Field) :
            val imm* = put-types(imm(i))
            val i* = put-imm(i, imm*)
            put-type{i*, _} $
            bundle-field(type(imm*), name(i))
         (i:InstPort) :
            put-type{i, _} $
            bundle-field(lookup!(e, name(i)), port(i))

   match(map(put-types, c)) :
      (c:DefUInt) :
         [c, List(name(c) => UIntType(), e)]
      (c:DefSInt) :
         [c, List(name(c) => SIntType(), e)]
      (c:DefWire) :
         [c, List(name(c) => type(c), e)]
      (c:DefRegister) :
         [c, List(name(c) => type(c), e)]
      (c:DefMemory) :
         [c, List(name(c) => type(c), e)]
      (c:DefVector) :
         [c, List(name(c) => type(c), e)]
      (c:DefInstance) :
         [c, List(name(c) => type(module(c)), e)]
      (c:DefAccessor) :
         [c, List(name(c) => type(source(c)), e)]
      (c:Conditionally) :
         val [con*, con-e] = infer(conseq(c), e)
         val [alt*, alt-e] = infer(alt(c), e)
         [Conditionally(pred(c), con*, alt*), e]
      (c:Begin) :
         var current-e: List<KeyValue<Symbol,Type>> = e
         val body* = for c in body(c) map :
            val [c*, e*] = infer(c, current-e)
            current-e = e*
            c*
         [Begin(body*), current-e]
      (c:DoPrim) :
         val type* = infer(op(c), map(type, args(c)))
         [c, List(name(c) => type*, e)]
      (c) :
         [c, e]

defn infer (m:Module, e: List<KeyValue<Symbol, Type>>) -> Module :
   val env = append{_, e} $
      for p in ports(m) map :
         name(p) => type(p)
   val [body*, e*] = infer(body(m), env)
   Module(name(m), ports(m), body*)

defn infer-types (c:Circuit) -> Circuit :
   val env =
      for m in modules(c) map :
         name(m) => BundleType(ports(m))
   Circuit(map(infer{_, env}, modules(c)),
           main(c))

;============= INFER DIRECTIONS ============================
defn infer-dir (m:Module) :
   val directions = HashTable<Symbol,Direction>(symbol-hash)
   val insts = HashTable<Symbol,Type>(symbol-hash)
   defn find-dirs (c:Command) :
      match(c) :
         (c:DefUInt|DefSInt|DoPrim) :
            directions[name(c)] = OUTPUT
         (c:DefWire|DefRegister|DefAccessor) :
            directions[name(c)] = UNKNOWN-DIR
         (c:DefInstance) :
            insts[name(c)] = type(module(c))
         (c) :
            do(find-dirs, children(c))

   defn bundle-dir (t:Type, n:Symbol) :
      match(t) :
         (t:BundleType) :
            match(lookup-port(ports(t), n)) :
               (p:Port) : direction(p)
               (p) : UNKNOWN-DIR
         (t) : UNKNOWN-DIR
            
   defn put-dirs (i:Immediate, desired:Direction) -> Immediate :
      match(i) :
         (i:Ref) :
            val dir = let :
               match(get?(directions, name(i), false)) :
                  (d:False) :
                     UNKNOWN-DIR
                  (d:Direction) :
                     if d == UNKNOWN-DIR : desired
                     else : d
            put-dir(i, dir)
         (i:RegData) :
            put-dir(i, desired)
         (i:Field) :
            val port-dir = bundle-dir(type(imm(i)), name(i))
            val imm* = put-dirs(imm(i), port-dir * desired)
            put-dir{_, port-dir * direction(imm*)} $
               put-imm(i, imm*)
         (i:InstPort) :
            val type = insts[name(i)]
            val port-dir = bundle-dir(type, port(i))
            put-dir(i, port-dir)

   defn put-dirs (c:Command) :
      match(c) :
         (c:Connect) :
            val loc* = put-dirs(loc(c), INPUT)
            val exp* = put-dirs(exp(c), OUTPUT)
            Connect(loc*, exp*)
         (c:ConnectMany) :
            val loc* = put-dirs(loc(c), INPUT)
            val exps* = map(put-dirs{_, OUTPUT}, exps(c))
            val idx* = put-dirs(idx(c), OUTPUT)
            ConnectMany(idx*, loc*, exps*)
         (c:ManyConnect) :
            val locs* = map(put-dirs{_, INPUT}, locs(c))
            val exp* = put-dirs(exp(c), OUTPUT)
            val idx* = put-dirs(idx(c), OUTPUT)
            ManyConnect(idx*, locs*, exp*)
         (c) :
            val c* = map(put-dirs{_, OUTPUT}, c)
            map(put-dirs{_ as Command}, c*)

   ;Find all names and their directions
   for p in ports(m) do :
      directions[name(p)] = flip(direction(p))
   find-dirs(body(m))
   ;Create new module
   Module(name(m),
          ports(m),
          put-dirs(body(m)))

defn infer-dirs (c:Circuit) :
   Circuit(map(infer-dir, modules(c)),
           main(c))

;========= INFER DIRECTIONS OF ACCESSORS ===================
defn find-accessor-uses (c:Command) :
   to-list $ generate<Ref> :
      val accessors = Vector<Symbol>()
      defn find-use (imm:Immediate) :
         match(root-ref(imm)) :
            (root:Ref) :
               yield(root) when contains?(accessors, name(root))
            (root) : false
         imm
      loop(c) where :
         defn loop (c:Command) :
            match(map(find-use, c)) :
               (c:DefAccessor) : add(accessors, name(c))
               (c) : do(loop, children(c))

defn fold-accessor-uses (uses: List<Ref>) :
   val table = HashTable<Symbol,Ref>(symbol-hash)
   for use in uses do :
      match(get?(table, name(use), false)) :
         (r:Ref) :
            if direction(r) != direction(use) :
               throw $ PassException $ string-join $
               ["Accessor " name(use) " is used both as an INPUT and an OUTPUT."]
         (f:False) :
            table[name(use)] = use
   to-list(stream(value, table))

defn fill-accessor-dirs (c:Command, uses:List<Ref>) -> Command :
   match(c) :
      (c:DefAccessor) :
         val use = find({name(_) == name(c)}, uses)
         val dir =
            match(use) :
               (r:Ref) : direction(r)
               (d:False) : throw $ PassException $ string-join $
                           ["Accessor " name(c) " is never used. Unable to infer direction."]
         DefAccessor(name(c), source(c), dir, index(c))
      (c:Command) :
         map(fill-accessor-dirs{_, uses}, c)

defn infer-accessor-dirs (c:Circuit) :
   val modules* =
      for m in modules(c) map :
         val uses = fold-accessor-uses(find-accessor-uses(body(m)))
         val body* = fill-accessor-dirs(body(m), uses)
         Module(name(m), ports(m), body*)
   Circuit(modules*, main(c))


;============== EXPAND VECS ================================
defn expand-vecs (c: Command) :
   val vecs = Vector<DefVector>()
   defn expand (c:Command) :
      match(c) :
         (c:DefAccessor) :
            val vec = find({name(_) == name(source(c))}, vecs)
            match(vec) :
               (vec:DefVector) :
                  val ref = Ref(name(c), flip(direction(c)), type(source(c)))
                  switch {direction(c) == _} :
                     OUTPUT :
                        Begin $ to-list $ [
                           DefWire(name(c), type(source(c)))
                           ConnectMany(index(c), ref, args(vec))]
                     INPUT :
                        Begin $ to-list $ [
                           DefWire(name(c), type(source(c)))
                           ManyConnect(index(c), args(vec), ref)]
               (vec:False) :
                  c
         (c:DefVector) :
            add(vecs, c)
            EmptyCommand()
         (c) :
            map(expand, c)
   expand(c)

defn expand-vecs (c:Circuit) :
   val modules* =
      for m in modules(c) map :
         Module(name(m), ports(m), expand-vecs(body(m)))
   Circuit(modules*, main(c))


;=============== BUNDLE FLATTENING =========================
defn prefix (pre:Symbol, name:Symbol) :
   symbol-join([pre "/" name])
   
defn prefix-ports (pre:Symbol, ports:List<Port>) :
   for p in ports map :
      Port(prefix(pre, name(p)), direction(p), type(p))

defn flatten-ports (p:Port) -> List<Port> :
   match(type(p)) :
      (t:BundleType) :
         val ports = prefix-ports(name(p), map-append(flatten-ports, ports(t)))
         for port in ports map :
            Port(name(port), direction(p) * direction(port), type(port))
      (t:Type) :
         list(p)

defn flatten-type (t:Type) -> Type :
   match(t) :
      (t:BundleType) :
         BundleType $
         map-append(flatten-ports, ports(t))
      (t:Type) :
         t

defn flatten-imm (i:Immediate) -> Immediate :
   match(i) :
      (i:Field) :
         val imm* = flatten-imm(imm(i))
         val type* = flatten-type(type(i))
         put-type{_, type*} $
         put-imm(i, imm*)
      (i) :
         val type* = flatten-type(type(i))
         put-type(i, type*)

defn flatten-command (c: Command) -> Command :
   match(map(flatten-imm, c)) :
      (c:DefWire) : DefWire(name(c), flatten-type(type(c)))
      (c:DefRegister) : DefRegister(name(c), flatten-type(type(c)))
      (c:DefMemory) : DefMemory(name(c), flatten-type(type(c)), size(c))
      (c) : map(flatten-command, c)

defn flatten-bundles (m: Module) :
   val ports* = map-append(flatten-ports, ports(m))
   val body* = flatten-command(body(m))
   Module(name(m), ports*, body*)

defn flatten-bundles (c: Circuit) :
   Circuit(map(flatten-bundles, modules(c)), main(c))


;================== BUNDLE EXPANSION =======================
defn expand-bundles (i:Immediate) -> List<Immediate> :
   defn collapse (i:Immediate) :
      match(i) :
         (i:Field) :
            match(collapse(imm(i))) :
               (im:Ref) : Ref(prefix(name(im), name(i)), direction(i), type(i))
               (im:RegData) : RegData(prefix(name(im), name(i)), direction(i), type(i))
               (im:InstPort) : InstPort(name(im), prefix(port(im), name(i)), direction(i), type(i))
         (i) : i
   match(type(i)) :
      (t:BundleType) :
         for p in ports(t) map :
            collapse(Field(i, name(p), direction(i) * direction(p), type(p)))
      (t) :
         list(collapse(i))

defmulti expand-bundles (c:Command) -> Command
defmethod expand-bundles (c:Command) :
   map(expand-bundles{_ as Command}, c)

defmethod expand-bundles (c:DefWire) :
   match(type(c)) :
      (t:BundleType) :
         Begin $
         for p in prefix-ports(name(c), ports(t)) map :
            DefWire(name(p), type(p))
      (t) :
         c

defmethod expand-bundles (c:DefRegister) :
   match(type(c)) :
      (t:BundleType) :
         Begin $
         for p in prefix-ports(name(c), ports(t)) map :
            DefRegister(name(p), type(p))
      (t) :
         c

defmethod expand-bundles (c:Connect) :
   val locs = expand-bundles(loc(c))
   val exps = expand-bundles(exp(c))
   Begin $
   for (loc in locs, exp in exps) map :
      switch {direction(loc) == _} :
         INPUT : Connect(loc, exp)
         OUTPUT : Connect(exp, loc)

defmethod expand-bundles (c:ManyConnect) :
   val locs-list = transpose(map(expand-bundles, locs(c)))
   val exps = expand-bundles(exp(c))
   Begin $
   for (locs in locs-list, exp in exps) map :
      switch {direction(exp) == _} :
         OUTPUT : ManyConnect(idx(c), locs, exp)
         INPUT : ConnectMany(idx(c), exp, locs)

defmethod expand-bundles (c:ConnectMany) :
   val locs = expand-bundles(loc(c))
   val exps-list = transpose(map(expand-bundles, exps(c)))
   Begin $
   for (loc in locs, exps in exps-list) map :
      switch {direction(loc) == _} :
         INPUT : ConnectMany(idx(c), loc, exps)
         OUTPUT : ManyConnect(idx(c), exps, loc)

defmethod expand-bundles (c:DefAccessor) :
   match(type(source(c))) :
      (t:BundleType) :
         val sources = expand-bundles(source(c))
         Begin $
         for (p in prefix-ports(name(c), ports(t)), s in sources) map :
            DefAccessor(name(p), s as Ref, direction(c), index(c))
      (t) :
         c

defmethod expand-bundles (c:DefMemory) :
   match(type(c)) :
      (t:BundleType) :
         Begin $
         for p in prefix-ports(name(c), ports(t)) map :
            DefMemory(name(p), type(p), size(c))
      (t) :
         c

defn expand-bundles (c:Circuit) :
   val c* = flatten-bundles(c)
   val modules* =
      for m in modules(c*) map :
         Module(name(m),
                ports(m),
                expand-bundles(body(m)))
   Circuit(modules*, main(c*))

;================ CLEANUP COMMANDS =========================
defn cleanup (c:Command) :
   match(c) :
      (c:Begin) :
         val cs = to-list $ generate<Command> :
            loop(c) where :
               defn loop (c:Command) :
                  match(c) :
                     (c:Begin) : do(loop, body(c))
                     (c:EmptyCommand) : false
                     (c) : yield(cleanup(c))
         switch {length(cs) == _} :
            0 : EmptyCommand()
            1 : head(cs)
            else : Begin(cs)
      (c) : map(cleanup{_ as Command}, c)

defn cleanup (c:Circuit) :
   val modules* =
      for m in modules(c) map :
         Module(name(m), ports(m), cleanup(body(m)))
   Circuit(modules*, main(c))


;=========== CONVERT MULTI CONNECTS to WHEN ================
defn convert-connect-many (c:ConnectMany|ManyConnect) :
   Begin{to-list(_)} $
   generate<Command> :
      defn make-int (i:Int) :
         val name = gensym()
         yield(DefUInt(name, i, UnknownWidth()))
         Ref(name, OUTPUT, UIntType())
      defn compare (x:Immediate, i:Int) :
         val name = gensym()
         yield(DoPrim(name, EQUAL-OP, list(x, make-int(i)), List()))
         Ref(name, OUTPUT, UIntType())
      match(c) :
         (c:ConnectMany) :
            for (i in 0 to false, exp in exps(c)) do :
               yield $
               Conditionally(compare(idx(c), i),
                  Connect(loc(c), exp)
                  EmptyCommand())
         (c:ManyConnect) :
            for (i in 0 to false, loc in locs(c)) do :
               yield $
               Conditionally(compare(idx(c), i),
                  Connect(loc, exp(c))
                  EmptyCommand())

defn expand-command-multi-connects (c:Command) :
   match(c) :
      (c:ConnectMany) : convert-connect-many(c)
      (c:ManyConnect) : convert-connect-many(c)
      (c) : map(expand-command-multi-connects, c)

defn expand-multi-connects (c:Circuit) :
   val modules* =
      for m in modules(c) map :
         val body* = expand-command-multi-connects(body(m))
         Module(name(m), ports(m), body*)
   Circuit(modules*, main(c))

;================ EXPAND WHENS =============================
definterface SymbolicValue
defstruct ImmediateValue <: SymbolicValue :
  imm: Immediate
defstruct WhenValue <: SymbolicValue :
  pred: Immediate
  conseq: SymbolicValue
  alt: SymbolicValue
defstruct VoidValue <: SymbolicValue

defn eqv? (v1:SymbolicValue, v2:SymbolicValue) :
   match(v1, v2) :
      (v1:ImmediateValue, v2:ImmediateValue) :
         eqv?(imm(v1), imm(v2))
      (v1:WhenValue, v2:WhenValue) :
         eqv?(pred(v1), pred(v2)) and
         eqv?(conseq(v1), conseq(v2)) and
         eqv?(alt(v1), alt(v2))
      (v1:VoidValue, v2:VoidValue) : true
      (v1, v2) : false

defn merge-env (pred:Immediate,
                con-env: List<KeyValue<Immediate,SymbolicValue>>,
                alt-env: List<KeyValue<Immediate,SymbolicValue>>) :
   val env = Vector<KeyValue<Immediate, SymbolicValue>>()
   for entry in con-env do :
      if lookup(env, key(entry)) == false :
         match(lookup(alt-env, key(entry))) :
            (sv:SymbolicValue) :
               if eqv?(sv, value(entry)) : add(env, entry)
               else : add(env, key(entry) => WhenValue(pred, value(entry), sv))
            (f:False) : add(env, entry)
   for entry in alt-env do :
      if lookup(env, key(entry)) == false :
         add(env, entry)
   to-list(env)

defn simplify-env (env: List<KeyValue<Immediate,SymbolicValue>>) :
   val seen = Vector<Immediate>()
   defn seen? (i:Immediate) :
      find(eqv?{i, _}, seen) != false

   to-list $
   for entry in env filter :
      if not seen?(key(entry)) :
         add(seen, key(entry))
         true

defn expand-whens (c:Command,
                   env:List<KeyValue<Immediate,SymbolicValue>>) :
   val cs = Vector<Command>()
   defn eval (c:Command, env:List<KeyValue<Immediate,SymbolicValue>>) ->
              List<KeyValue<Immediate,SymbolicValue>> :
      match(c) :
         (c:DefUInt|DefSInt|DoPrim) :
            add(cs, c)
            env
         (c:DefWire) :
            add(cs, c)
            val ref = Ref(name(c), INPUT, type(c))
            List(ref => VoidValue(), env)
         (c:DefRegister) :
            add(cs, c)
            val ref = RegData{name(c), _, type(c)}
            List(ref(INPUT) => ImmediateValue(ref(OUTPUT)), env)            
         (c:DefInstance) :
            add(cs, c)
            to-list $ generate<KeyValue<Immediate, SymbolicValue>> :
               val module-type = type(module(c)) as BundleType
               for p in ports(module-type) do :
                  if direction(p) == INPUT :
                     val ref = InstPort(name(c), name(p), INPUT, type(p))
                     yield(ref => VoidValue())
               do(yield, env)      
         (c:DefMemory) :
            add(cs, c)
            env
         (c:DefAccessor) :
            error("Not yet Implemented: Needs Enable for Memories")
         (c:Conditionally) :
            val con-env = eval(conseq(c), env)
            val alt-env = eval(alt(c), env)
            merge-env(pred(c), con-env, alt-env)
         (c:Begin) :
            reduce{_, env, body(c)} $ fn (e, c) :
               eval(c, e)
         (c:Connect) :
            List(loc(c) => ImmediateValue(exp(c)), env)
         (c:EmptyCommand) :
            env

   defn convert-symbolic (sv:SymbolicValue) :
      match(sv) :
         (sv:VoidValue) :
            throw $ PassException $ string-join $
            ["Uninitialized Connection."]
         (sv:ImmediateValue) :
            imm(sv)
         (sv:WhenValue) :
            val name = gensym()
            val conseq* = convert-symbolic(conseq(sv))
            val alt* = convert-symbolic(alt(sv))
            add{cs, DoPrim(name, MULTIPLEX-OP, _, List())} $
              list(pred(sv), conseq*, alt*)
            Ref(name, OUTPUT, type(conseq*))

   val env* = simplify-env(eval(c, env))
   for entry in env* do :
      add{cs, Connect(key(entry), _)} $
      convert-symbolic(value(entry))
   Begin(to-list(cs))

defn expand-whens (m:Module) :
   val env = let :
      val out-ports = filter({direction(_) == OUTPUT}, ports(m))
      to-list $
      for p in out-ports stream :
         val ref = Ref(name(p), INPUT, type(p))
         ref => VoidValue()
   val body* = expand-whens(body(m), env)
   Module(name(m), ports(m), body*)

defn expand-whens (c:Circuit) :
   val modules* = map(expand-whens, modules(c))
   Circuit(modules*, main(c))


;=============== CONSTRAINT GENERATION =====================
defn generate-constraints (c:Circuit) -> [Circuit, Vector<WConstraint>] :
   ;======== CONSTRAINTS ===============
   val cs = Vector<WConstraint>()

   ;========= WIDTH EXPRESSIONS ========
   ;Applying Width Operators
   defn to-exp (w:Width) :
      match(w) :
         (w:WidthVar) : EVar(name(w))
         (w:IntWidth) : ELit(value(w))
   defn wequal (ret:Symbol, a:Width) :
      add(cs, WidthEqual(ret, to-exp(a)))
   defn apply (ret:Symbol, f: (Exp, Exp) -> Exp, a:Width, b:Int) :
      add(cs, WidthEqual(ret, f(to-exp(a), ELit(b))))
   defn apply (ret:Symbol, f: (Exp, Exp) -> Exp, a:Width, b:Width) :
      add(cs, WidthEqual(ret, f(to-exp(a), to-exp(b))))
   
   ;Width Operators
   defn EMaxInc (e1:Exp, e2:Exp) :
      EPlus(ELit(1), EMax(e1, e2))

   ;Compute the resulting width of a primop
   defn primop-constraint (ret:Symbol, op:PrimOp, widths: List<Width>, consts: List<Int>) :
      switch {op == _} :
         ADD-OP : apply(ret, EMaxInc, widths[0], widths[1])
         ADD-MOD-OP : apply(ret, EMax, widths[0], widths[1])
         SUB-MOD-OP : apply(ret, EMax, widths[0], widths[1])
         MINUS-OP : apply(ret, EMaxInc, widths[0], widths[1])
         TIMES-OP : apply(ret, EPlus, widths[0], widths[1])
         DIVIDE-OP : apply(ret, EMinus, widths[0], widths[1])
         MOD-OP : wequal(ret, widths[1])
         SHIFT-LEFT-OP : apply(ret, EPlus, widths[0], consts[0])
         SHIFT-RIGHT-OP : apply(ret, EMinus, widths[0], consts[0])
         PAD-OP : wequal(ret, IntWidth(consts[0]))
         BIT-AND-OP : apply(ret, EMax, widths[0], widths[1])
         BIT-OR-OP : apply(ret, EMax, widths[0], widths[1])
         BIT-XOR-OP : apply(ret, EMax, widths[0], widths[1])
         CONCAT-OP : apply(ret, EPlus, widths[0], widths[1])
         BIT-SELECT-OP : wequal(ret, IntWidth(1))
         BITS-SELECT-OP : wequal(ret, IntWidth(consts[0]))
         MULTIPLEX-OP : apply(ret, EMax, widths[1], widths[2])
         LESS-OP : wequal(ret, IntWidth(1))
         LESS-EQ-OP : wequal(ret, IntWidth(1))
         GREATER-OP : wequal(ret, IntWidth(1))
         GREATER-EQ-OP : wequal(ret, IntWidth(1))
         EQUAL-OP : wequal(ret, IntWidth(1))

   ;Compute minimum width required for unsigned integer
   defn min-int-width (i:Int) :
      var v:Int = i
      var n:Int = 0
      while v != 0 :
         v = v >> 1
         n = n + 1
      n

   ;Compute minimum width required for signed integer
   defn min-sint-width (i:Int) :
      if i > 0 : min-int-width(i) + 1
      else : min-int-width(-1 - i) + 1

   ;========= WIDTH VARIABLES ==========
   defn widthvar? (w:Width) :
      match(w) :
         (w:UnknownWidth) : WidthVar(gensym())
         (w) : w
         
   defn add-type-width-vars (t:Type) -> Type :
      match(t) :
         (t:UIntType) : UIntType(widthvar?(width(t)))
         (t:SIntType) : SIntType(widthvar?(width(t)))

   defn add-width-vars (m:Module, env:List<KeyValue<Symbol,Type>>) -> Module :
      val types = HashTable<Symbol,Type>(symbol-hash)
      for entry in env do :
         types[key(entry)] = value(entry)
      for p in ports(m) do :
         types[name(p)] = type(p)
         
      defn add-imm-width-vars (i:Immediate) :
         match(i) :
            (i:Ref) :
               put-type(i, types[name(i)])
            (i:RegData) :
               put-type(i, types[name(i)])
            (i:InstPort) :
               val type* = bundle-field(types[name(i)], port(i))
               put-type(i, type*)

      defn add-width-vars (c:Command) :
         match(map(add-imm-width-vars, c)) :
            (c:DefUInt) :
               val width* =
                  match(width(c)) :
                     (w:UnknownWidth) : IntWidth(min-int-width(value(c)))
                     (w) : w
               types[name(c)] = UIntType(width*)
               DefUInt(name(c), value(c), width*)
            (c:DefSInt) :
               val width* =
                  match(width(c)) :
                     (w:UnknownWidth) : IntWidth(min-sint-width(value(c)))
                     (w) : w
               types[name(c)] = SIntType(width*)
               DefSInt(name(c), value(c), width*)
            (c:DoPrim) :
               val type* = add-type-width-vars(infer(op(c), map(type, args(c))))
               match(width(type*)) :
                  (w:WidthVar) :
                     val widths = map(width{type(_)}, args(c))
                     primop-constraint(name(w), op(c), widths, consts(c))
                  (w) : false                  
               types[name(c)] = type*
               c
            (c:DefWire) :
               val type* = add-type-width-vars(type(c))
               types[name(c)] = type*
               DefWire(name(c), type*)
            (c:DefRegister) :
               val type* = add-type-width-vars(type(c))
               types[name(c)] = type*
               DefRegister(name(c), type*)
            (c:DefInstance) :
               types[name(c)] = type(module(c))
               c
            (c:DefMemory) :
               types[name(c)] = type(c)
               c
            (c:DefAccessor) :
               types[name(c)] = type(source(c))
               c
            (c:Connect) :
               match(width(type(loc(c)))) :
                  (w:WidthVar) :
                     val exp-width = width(type(exp(c)))
                     add(cs, WidthGreater(name(w), to-exp(exp-width)))
                  (w) : false
               c   
            (c) :
               map(add-width-vars, c)

      val body* = add-width-vars(body(m))
      Module(name(m), ports(m), body*)

   defn add-port-width-vars (m:Module) -> Module :
      val ports* =
         for p in ports(m) map :
            val type* = add-type-width-vars(type(p))
            Port(name(p), direction(p), type*)
      Module(name(m), ports*, body(m))

   defn add-width-vars (c:Circuit) :
      val modules* = map(add-port-width-vars, modules(c))
      val env = for m in modules* map :
                   name(m) => BundleType(ports(m))
      Circuit(map(add-width-vars{_, env}, modules*),
              main(c))

   ;Return generated constraints
   [add-width-vars(c), cs]


;=============== INFER WIDTHS ==============================
defn fill-widths (w:Width, get-width: (Symbol) -> Width) :
   match(w) :
      (w:WidthVar) : get-width(name(w))
      (w) : w

defn fill-widths (t:Type, get-width: (Symbol) -> Width) :
   match(t) :
      (t:UIntType) : UIntType(fill-widths(width(t), get-width))
      (t:SIntType) : SIntType(fill-widths(width(t), get-width))
      (t:BundleType) : BundleType $ map(fill-widths{_, get-width}, ports(t))
         
defn fill-widths (p:Port, get-width: (Symbol) -> Width) :
   Port(name(p), direction(p), fill-widths(type(p), get-width))
   
defn fill-widths (i:Immediate, get-width: (Symbol) -> Width) :
   val type* = fill-widths(type(i), get-width)
   put-type(i, type*)

defn fill-widths (c:Command, get-width: (Symbol) -> Width) -> Command :
   match(c) :
      (c:DefWire) : DefWire(name(c), fill-widths(type(c), get-width))
      (c:DefRegister) : DefRegister(name(c), fill-widths(type(c), get-width))
      (c:DefMemory) : DefMemory(name(c), fill-widths(type(c), get-width), size(c))
      (c) :
         val c* = map(fill-widths{_ as Immediate, get-width}, c)
         map(fill-widths{_ as Command, get-width}, c*)

defn fill-widths (m:Module, get-width: (Symbol) -> Width) :
   Module(name(m),
          map(fill-widths{_, get-width}, ports(m)),
          fill-widths(body(m), get-width))

defn fill-widths (c:Circuit, solved: Streamable<WidthEqual>) :
   ;Construct get-width function
   val table = HashTable<Symbol,Width>(symbol-hash)
   for eqn in solved do :
      table[name(eqn)] = IntWidth(width(value(eqn) as ELit))
   defn get-width (n:Symbol) :
      get?(table, n, UnknownWidth())

   val modules* = map(fill-widths{_, get-width}, modules(c))
   Circuit(modules*, main(c))   

defn infer-widths (c:Circuit) :
   val [c*, cs] = generate-constraints(c)
   val solved = solve-widths(cs)
   fill-widths(c*, solved)   

;================== WIDTH MATCHING =========================
defn pad-immediate (i:Immediate, desired-w:Int) -> [Immediate List<Command>] :
   val cs = Vector<Command>()   
   val w = width(type(i)) as IntWidth
   val imm* = 
      if value(w) < desired-w :
         val name = gensym()
         add(cs, DoPrim(name, PAD-OP, list(i), list(desired-w)))
         val type* = put-width(type(i), IntWidth(desired-w))
         Ref(name, OUTPUT, type*)
      else :
         i
   [imm* to-list(cs)]      

defn match-prim (c:DoPrim) :
   ;Find desired width
   val match-args =
      switch {op(c) == _} :
         BIT-AND-OP : args(c)
         BIT-OR-OP : args(c)
         BIT-XOR-OP : args(c)
         EQUAL-OP : args(c)
         MULTIPLEX-OP : tail(args(c))
   val desired-w = maximum $
      for a in match-args stream :
         val w = width(type(a)) as IntWidth
         value(w)

   ;Create commands for padding
   Begin{to-list(_)} $ generate<Command> :
      val match-args* =
         for a in match-args map :
            val [a* cs] = pad-immediate(a, desired-w)
            do(yield, cs)
            a*
      val prim-args =
         switch {op(c) == _} :
            BIT-AND-OP : match-args*
            BIT-OR-OP : match-args*
            BIT-XOR-OP : match-args*
            EQUAL-OP : match-args*
            MULTIPLEX-OP : List(head(args(c)), match-args*)
      yield(DoPrim(name(c), op(c), prim-args, consts(c)))

defn match-connect (c:Connect) :
   val desired-w = let :
      val w = width(type(loc(c))) as IntWidth
      value(w)
   val [exp*, cs] = pad-immediate(exp(c), desired-w)
   Begin{append(cs, list(_))} $
      Connect(loc(c), exp*)
         
defn width-match (c:Command) -> Command :
   match(c) :
      (c:DoPrim) :
         switch {op(c) == _} :
            BIT-AND-OP : match-prim(c)
            BIT-OR-OP : match-prim(c)
            BIT-XOR-OP : match-prim(c)
            MULTIPLEX-OP : match-prim(c)
            EQUAL-OP : match-prim(c)
            else : c
      (c:Connect) :
         match-connect(c)
      (c) : map(width-match{_ as Command}, c)

defn width-match (c:Circuit) :
   val modules* =
      for m in modules(c) map :
         Module(name(m), ports(m), width-match(body(m)))
   Circuit(modules*, main(c))

;============= SHIM ========================================
defn shim (i:Immediate) -> Immediate :
   match(i) :
      (i:RegData) :
         Ref(name(i), direction(i), type(i))
      (i:InstPort) :
         val inst = Ref(name(i), UNKNOWN-DIR, UnknownType())
         Field(inst, port(i), direction(i), type(i))
      (i:Field) :
         val imm* = shim(imm(i))
         put-imm(i, imm*)
      (i) : i

defn shim (c:Command) -> Command :
   val c* = map(shim{_ as Immediate}, c)
   map(shim{_ as Command}, c*)

defn shim (c:Circuit) -> Circuit :
   val modules* =
      for m in modules(c) map :
         Module(name(m), ports(m), shim(body(m)))
   Circuit(modules*, main(c))   

;================== INLINE MODULES =========================
defn cat-name (p: String|Symbol, s: String|Symbol) -> Symbol :
   if p == "" or p == `this : ;; TODO: REMOVE THIS WHEN `THIS GETS REMOVED
      to-symbol(s)
   else if s == `this :       ;; TODO: DITTO
      to-symbol(p)
   else :
      symbol-join([p, "/", s])

defn inline-command (c: Command, mods: HashTable<Symbol, Module>, prefix: String, cmds: Vector<Command>) :
   defn rename (n: Symbol) -> Symbol :
      cat-name(prefix, n)
   defn inline-name (i:Immediate) -> Symbol :
      match(i) :
         (r:Ref) :   rename(name(r))
         (f:Field) : cat-name(inline-name(imm(f)), name(f))
         (f:Index) : cat-name(inline-name(imm(f)), to-string(value(f)))
   defn inline-imm (i:Immediate) -> Ref :
      Ref(inline-name(i), direction(i), type(i))
   match(c) :
      (c:DefUInt) :      add(cmds, DefUInt(rename(name(c)), value(c), width(c)))
      (c:DefSInt) :      add(cmds, DefSInt(rename(name(c)), value(c), width(c)))
      (c:DefWire) :      add(cmds, DefWire(rename(name(c)), type(c)))
      (c:DefRegister) :  add(cmds, DefRegister(rename(name(c)), type(c)))
      (c:DefMemory) :    add(cmds, DefMemory(rename(name(c)), type(c), size(c)))
      (c:DefInstance) :  inline-module(mods, mods[name(module(c))], to-string(rename(name(c))), cmds)
      (c:DoPrim) :       add(cmds, DoPrim(rename(name(c)), op(c), map(inline-imm, args(c)), consts(c)))
      (c:DefAccessor) :  add(cmds, DefAccessor(rename(name(c)), inline-imm(source(c)), direction(c), inline-imm(index(c))))
      (c:Connect) :      add(cmds, Connect(inline-imm(loc(c)), inline-imm(exp(c))))
      (c:Begin) :        do(inline-command{_, mods, prefix, cmds}, body(c))
      (c:EmptyCommand) : c
      (c) :              error("Unsupported command")

defn inline-port (p: Port, prefix: String) -> Command :
   DefWire(cat-name(prefix, name(p)), type(p))

defn inline-module (mods: HashTable<Symbol, Module>, mod: Module, prefix: String, cmds: Vector<Command>) :
   do(add{cmds, _}, map(inline-port{_, prefix}, ports(mod)))
   inline-command(body(mod), mods, prefix, cmds)

defn inline-modules (c: Circuit) -> Circuit :
   val cmds = Vector<Command>()
   val mods = HashTable<Symbol, Module>(symbol-hash)
   for mod in modules(c) do :
      mods[name(mod)] = mod
   val top = mods[main(c)]
   inline-command(body(top), mods, "", cmds)
   val main* = Module(name(top), ports(top), Begin(to-list(cmds)))
   Circuit(list(main*), name(top))


;============= FLO PRINTER ======================================
;;; TODO:
;;; not supported gt, lte

defn flo-op-name (op:PrimOp) -> String :
   switch {op == _} :
      ADD-OP :         "add"
      ADD-MOD-OP :     "add"
      MINUS-OP :       "sub"
      SUB-MOD-OP :     "sub"
      TIMES-OP :       "mul" ;; todo: signed version
      DIVIDE-OP :      "div" ;; todo: signed version
      MOD-OP :         "mod" ;; todo: signed version
      SHIFT-LEFT-OP :  "lsh" ;; todo: signed version
      SHIFT-RIGHT-OP : "rsh"
      PAD-OP :         "pad" ;; todo: signed version
      BIT-AND-OP :     "and"
      BIT-OR-OP :      "or"
      BIT-XOR-OP :     "xor"
      CONCAT-OP :      "cat"
      BIT-SELECT-OP :  "rsh"
      BITS-SELECT-OP : "rsh"
      LESS-OP :        "lt"  ;; todo: signed version
      LESS-EQ-OP :     "lte" ;; todo: swap args
      GREATER-OP :     "gt"  ;; todo: swap args
      GREATER-EQ-OP :  "gte" ;; todo: signed version
      EQUAL-OP :       "eq"
      MULTIPLEX-OP :   "mux"
      else : error $ string-join $
             ["Unable to print Primop: " op]

defn emit (o:OutputStream, top:Symbol, ports:HashTable<Symbol, Port>, lits:HashTable<Symbol, DefUInt>, elt) :
  match(elt) :
    (e:String|Symbol|Int) :
       print(o, e)
    (e:Ref) :
       if key?(lits, name(e)) :
         val lit = lits[name(e)]
         print-all(o, [value(lit) "'" width(lit)])
       else :
         if key?(ports, name(e)) :
           print-all(o, [top "::"])
         print(o, name(e))
    (e:IntWidth) :
       print(o, value(e))
    (e:PrimOp) :
       print(o, flo-op-name(e))
    (e) :
       println-all(["EMIT " e])
       error("Unable to emit")

defn emit-all (o:OutputStream, top:Symbol, ports:HashTable<Symbol, Port>, lits:HashTable<Symbol, DefUInt>, elts: Streamable) :
  for e in elts do : emit(o, top, ports, lits, e)

defn prim-width (type:Type) -> Width :
  match(type) : 
    (t:UIntType) : width(t) 
    (t:SIntType) : width(t)
    (t) :          error("Bad prim width type")

defn emit-command (o:OutputStream, cmd:Command, top:Symbol, lits:HashTable<Symbol, DefUInt>, regs:HashTable<Symbol, DefRegister>, accs:HashTable<Symbol, DefAccessor>, ports:HashTable<Symbol, Port>, outs:HashTable<Symbol, Port>) :
  match(cmd) :
    (c:DefUInt) :
       lits[name(c)] = c
    (c:DefSInt) :
       emit-all(o, top, ports, lits, [name(c) " = " value(c) "'" width(c) "\n"])
    (c:DoPrim) : ;; NEED TO FIGURE OUT WHEN WIDTHS ARE NECESSARY AND EXTRACT
       emit-all(o, top, ports, lits, [name(c) " = " op(c)])
       for arg in args(c) do : 
         print(o, " ")
         emit(o, top, ports, lits, arg)
       for const in consts(c) do : 
         print(o, " ")
         emit(o, top, ports, lits, const)
       print("\n")
    (c:DefRegister) :
       regs[name(c)] = c
    (c:DefMemory) :
       emit-all(o, top, ports, lits, [name(c) " : mem'" prim-width(type(c)) " " size(c) "\n"])
    (c:DefAccessor) :
       accs[name(c)] = c
    (c:Connect) :
       val dst = name(loc(c) as Ref)
       val src = name(exp(c) as Ref)
       if key?(regs, dst) :
          val reg = regs[dst]
          emit-all(o, top, ports, lits, [dst " = reg'" prim-width(type(reg)) " 0'" prim-width(type(reg)) " " exp(c) "\n"])
       else if key?(accs, dst) :
          val acc = accs[dst]
          ;; assert(direction(acc) == OUTPUT)
          emit-all(o, top, ports, lits, [dst " = wr " source(acc) " " index(acc) " " exp(c) "\n"])
       else if key?(outs, dst) :
          val out = outs[dst]
          emit-all(o, top, ports, lits, [top "::" dst " = out'" prim-width(type(out)) " " exp(c) "\n"])
       else if key?(accs, src) :
          val acc = accs[src]
          ;; assert(direction(acc) == INPUT)
          emit-all(o, top, ports, lits, [dst " = rd " source(acc) " " index(acc) "\n"])
       else :
          emit-all(o, top, ports, lits, [dst " = mov " exp(c) "\n"])
    (c:Begin) :
       do(emit-command{o, _, top, lits, regs, accs, ports, outs}, body(c))
    (c:DefWire|EmptyCommand) :
       print("")
    (c) :
       error("Unable to print command")

defn emit-module (o:OutputStream, m:Module) :
   val regs  = HashTable<Symbol, DefRegister>(symbol-hash)
   val accs  = HashTable<Symbol, DefAccessor>(symbol-hash)
   val lits  = HashTable<Symbol, DefUInt>(symbol-hash)
   val outs  = HashTable<Symbol, Port>(symbol-hash)
   val portz = HashTable<Symbol, Port>(symbol-hash)
   for port in ports(m) do :
      portz[name(port)] = port
      if direction(port) == OUTPUT :
         outs[name(port)] = port
      else if name(port) == `reset :
         print-all(o, [name(m) "::reset = rst\n"])
      else :
         print-all(o, [name(m) "::" name(port) " = " "in'" prim-width(type(port)) "\n"])
   emit-command(o, body(m), name(m), lits, regs, accs, portz, outs)

public defn emit-circuit (o:OutputStream, c:Circuit) :
   emit-module(o, modules(c)[0])
   

;============= DRIVER ======================================
public defn run-passes (c: Circuit) :
  var c*:Circuit = c
  println("Check Duplicates")
  check-duplicates(c*)
  println("Resolve Kinds")
  c* = resolve-kinds(c*)
  println("Make Explicit Reset")
  c* = make-explicit-reset(c*)
  println("Initialize Registers")
  c* = initialize-registers(c*)
  println("Infer Types")
  c* = infer-types(c*)
  println("Infer Directions")
  c* = infer-dirs(c*)
  println("Infer Accessor Directions")
  c* = infer-accessor-dirs(c*)
  println("Expand Vecs")
  c* = expand-vecs(c*)
  println("Expand Bundles")
  c* = expand-bundles(c*)
  println("Cleanup Circuit")
  c* = cleanup(c*)
  println("Expand Multi Connects")
  c* = expand-multi-connects(c*)
  println("Expand Whens")
  c* = expand-whens(c*)
  println("Infer Widths")
  c* = infer-widths(c*)
  println("Pad Widths")
  c* = width-match(c*)
  println("Shim for Jonathan's Passes")
  c* = shim(c*)
  println("Inline Modules")
  c* = inline-modules(c*)
  c*
